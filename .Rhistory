text = element_text(size=16),
strip.text = element_text(face = "italic"))
hs %>%
ggplot(aes(x=day, y=X50., group=factor(stage), col=factor(stage))) +
ggtitle("Host-seeking Ae. albopictus Interquantile range abundance") +
geom_ribbon(aes(ymin=X25., ymax=X75., fill=factor(stage)),
col="white",
alpha=0.2,
outline.type="full") +
geom_line(linewidth=0.8) +
# ylim(0,10)+
labs(x="Date", y="Interquantile range abundance", col="Stage", fill="Stage") +
# facet_wrap(~stage, scales = "free_y") +
theme_classic() +
theme(legend.pos="bottom",
text = element_text(size=16),
strip.text = element_text(face = "italic"))
adci <- function(input_sim = NULL, stage = NULL, sub_stage = NULL,
breaks = c(0.25, 0.5, 0.75), eval_date = NULL, n.clusters = 1,
type = "N") {
# Preliminary Checks
if (!is.numeric(eval_date)) stop("eval_date not defined, exiting...")
if (is.null(input_sim)) stop("Provide input simulations")
# Translate compartments, a bit wordy but it should grep widely.
get_comp <- function(stage) {
stage <- tolower(stage)
if (grepl("^eg", stage)) return(1)
if (grepl("^juv", stage)) return(2)
if (grepl("^ad", stage)) return(3)
if (grepl("^dia", stage)) return(4)
return(NULL)
}
comp <- get_comp(stage)
stage <- c("Egg", "Juvenile", "Adult", "DiapauseEgg")[comp]
coords <- input_sim@coordinates
dd <- max(sapply(input_sim@simulation, function(x) length(x))) # Max days in iterations
# Non-spatial Simulation
if (input_sim@scale == "ws") {
message("Weather station scale input simulation provided.")
if (input_sim@compressed_output) {
message("Compressed simulation provided")
message(paste("Computing abundance for ", stage, " estimated over the temporal profile"))
all.matrix <- lapply(1:input_sim@n_iterations, function(x) {
sapply(eval_date, function(y) {
unlist(input_sim@simulation[[x]][y])[comp]
})
})
all.matrix <- lapply(all.matrix, function(row) {
length_diff = length(eval_date) - length(row)
if (length_diff > 0) {
c(row, rep(NA, length_diff))
} else {
row
}
})
all.matrix <- do.call(cbind, all.matrix)
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) {
quantile(x, probs=breaks, na.rm=T)
})), day=eval_date, stage=stage)
} else {
message("Uncompressed simulation provided")
# Check if sub_stage is NULL and handle accordingly.
if (is.null(sub_stage)) {
sub_stage <- AedeslifeHistoryList$codesheet[!is.na(AedeslifeHistoryList$codesheet[[stage]]), stage]
message(paste("Computing", stage, "abundance..." ))
compute_values <- function(x) {
vals <- sapply(eval_date, function(y) {
sum(do.call(rbind, input_sim@simulation[[x]][y][1])[sub_stage],na.rm=TRUE)
})
c(vals, rep(NA, max(0, length(eval_date) - length(vals))))
}
all.matrix <- do.call(cbind, mclapply(1:length(input_sim@simulation), mc.cores=n.clusters, compute_values))
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) quantile(x, probs=breaks, na.rm=T))), day=eval_date, stage=stage)
} else {
tabCoord <- which(apply(AedeslifeHistoryList$speciesheet, 1:2, function(x) grepl(sub_stage, x)), arr.ind = TRUE)[1,]
message(paste("Computing sub-compartment", sub_stage, names(AedeslifeHistoryList$speciesheet)[tabCoord[2]], "abundance..." ))
all.matrix <- do.call(cbind, mclapply(1:input_sim@n_iterations, mc.cores=n.clusters, function(y) {
sapply(eval_date, function(x) sum(input_sim@simulation[[y]][x][[1]][tabCoord[2],,tabCoord[1]]))
}))
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) quantile(x, probs=breaks, na.rm=TRUE))), day=eval_date, stage=stage, sub_stage = sub_stage)
}
}
} else {
# Spatial Simulation
message(toupper(paste(input_sim@scale)), " scale input simulation provided")
if (input_sim@compressed_output) {
message("Compressed simulation provided")
if (nrow(coords) <= 1 || is.null(coords) || type == "O") {
message("Computing overall median temporal abundance estimate.")
# Here it derives the sum of all the individuals of a stage in a date
all.matrix <- do.call(cbind, mclapply(1:input_sim@n_iterations, mc.cores=n.clusters, function(x) {
sapply(eval_date, function(y) sum(input_sim@simulation[[x]][y][[1]][comp,]))
}))
# Then it calculates quantiles of the sum across iterations
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) {
quantile(x, probs=breaks, na.rm=TRUE)
})), day=eval_date, stage=stage)
} else {
message("Computing spatio-temporal abundance estimate.")
all.matrix <- mclapply(1:input_sim@n_iterations, mc.cores= n.clusters, function(x) {
sapply(eval_date, function(y) {
result <- do.call(cbind, input_sim@simulation[[x]][y][1])[comp, , drop = FALSE]
as.matrix(result)
})
})
all.matrix <- abind::abind(all.matrix, along=3)
all.matrix <- lapply(breaks, function(x) {
quant_res <- apply(all.matrix, c(1,2), quantile, probs=x, na.rm=T)
rast_obj <- rast(data.frame(coords, quant_res), type="xyz")
setNames(rast_obj, paste0("day", eval_date))
})
names(all.matrix) <- paste("q",breaks,sep="_")
}
} else {
message("Uncompressed simulation provided")
if (is.null(sub_stage) && type=="O") {
message(paste("Computing non-spatial", stage, "abundance..."))
all.matrix <- do.call(cbind, mclapply(1:input_sim@n_iterations, mc.cores=n.clusters, function(y) {
sapply(eval_date, function(x) sum(input_sim@simulation[[y]][x][[1]][comp,,]))
}))
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) quantile(x, probs=breaks, na.rm=TRUE))),
day=eval_date, stage=stage)
} else if (is.null(sub_stage) && type=="N")
{
message("Computing spatio-temporal abundance estimate at stage level.")
all.matrix <- mclapply(1:input_sim@n_iterations, mc.cores= n.clusters, function(x) {
sapply(eval_date, function(y) {
result <- rowSums(input_sim@simulation[[x]][y][1][[1]][comp, , ])
as.matrix(result)
})
})
all.matrix <- abind::abind(all.matrix, along=3)
all.matrix <- lapply(breaks, function(x) {
quant_res <- apply(all.matrix, c(1,2), quantile, probs=x, na.rm=T)
rast_obj <- rast(data.frame(coords, quant_res), type="xyz")
setNames(rast_obj, paste0("day", eval_date))
})
names(all.matrix) <- paste("q",breaks,sep="_")
} else {
if (nrow(coords) <= 1 || is.null(coords) || type == "O") {
tabCoord <- which(sapply(AedeslifeHistoryList$speciesheet, grepl, pattern=sub_stage), arr.ind=TRUE)[1,]
message(paste("Computing non-spatial sub-compartment", sub_stage, names(AedeslifeHistoryList$speciesheet)[tabCoord[2]], "abundance..."))
all.matrix <- do.call(cbind, mclapply(1:input_sim@n_iterations, mc.cores=n.clusters, function(y) {
sapply(eval_date, function(x) sum(input_sim@simulation[[y]][x][[1]][tabCoord[2],,tabCoord[1]]))
}))
all.matrix <- data.frame(t(apply(all.matrix, 1, function(x) quantile(x, probs=breaks, na.rm=TRUE))), day=eval_date, stage=stage, sub_stage = sub_stage)
}
else {
message("Computing spatio-temporal abundance estimate at substage level.")
tabCoord <- which(sapply(AedeslifeHistoryList$speciesheet, grepl, pattern=sub_stage), arr.ind=TRUE)[1,]
message(paste("Computing sub-compartment", sub_stage, names(AedeslifeHistoryList$speciesheet)[tabCoord[2]], "abundance..."))
# Compute all matrix based on the specific sub-stage
all.matrix <- mclapply(1:input_sim@n_iterations, mc.cores=n.clusters, function(y) {
sapply(eval_date, function(x) {
result <- input_sim@simulation[[y]][x][[1]][tabCoord[2],,tabCoord[1]]
as.matrix(result)
})
})
all.matrix <- abind::abind(all.matrix, along=3)
all.matrix.raster <- lapply(breaks, function(x) {
quant_res <- apply(all.matrix, c(1,2), quantile, probs=x, na.rm=T)
rast_obj <- rast(data.frame(coords, quant_res), type="xyz")
setNames(rast_obj, paste0("day", eval_date))
})
names(all.matrix.raster) <- paste(sub_stage, "q", breaks, sep="_")
all.matrix <- all.matrix.raster
}
}
}
}
return(all.matrix)
}
hs <- adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking" )
head(hs)
library(gstat)
library(terra)
gridDim <- 20 # 5000m/250 m = 20 columns and rows
xy <- expand.grid(x=1:gridDim, y=1:gridDim)
varioMod <- vgm(psill=0.5, range=100, model='Exp') # psill = partial sill = (sill-nugget)
# Set up an additional variable from simple kriging
zDummy <- gstat(formula=z~1,
locations = ~x+y,
dummy=TRUE,
beta=1,
model=varioMod,
nmax=1)
# Generate a randomly autocorrelated predictor data field
set.seed(123)
xyz <- predict(zDummy, newdata=xy, nsim=1)
utm32N <- "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
r <- terra::rast(nrow=gridDim, ncol=gridDim, crs=utm32N, ext=terra::ext(1220000,1225000, 5700000,5705000))
terra::values(r) <- xyz$sim1
# plot(r, main="SAC landscape")
# convert to a data.frame
df <- data.frame("id"=1:nrow(xyz), terra::crds(r))
bbox <- terra::as.polygons(terra::ext(r), crs=utm32N)
# Store Parameters for autocorrelation
autocorr_factor <- terra::values(r)
# "expand onto space" the temperature time series by multiplying it with the autocorrelated surface simulated above.
mat <- do.call(rbind, lapply(1:ncell(r), function(x) {
d_t <- sim_temp[[1]]$x*autocorr_factor[[x]]
return(d_t)
}))
# format simulated temperature
names(mat) <- paste0("d_", 1:ndays)
df_temp <- cbind(df, mat)
w <- sapply(df_temp[,-c(1:3)], function(x) as.integer(x*1000))
# define a two-column matrix of coordinates to identify each cell in the lattice grid.
cc <- df_temp[,c("x","y")]
simout <- dynamAedes.m(species="albopictus",
scale="rg",
jhwv=habitat_liters,
temps.matrix=w[,as.numeric(format(as.Date(str),"%j")):as.numeric(format(as.Date(endr),"%j"))],
coords.proj4=utm32N,
cells.coords=as.matrix(cc),
startd=str,
endd=endr,
n.clusters=cl,
iter=it,
intro.eggs=ie,
compressed.output=FALSE,
seeding=TRUE,
verbose=FALSE)
summary(simout)
# Retrieve the maximum number of simulated days
dd <- max(simout)
# Compute the inter-quartile of abundances along the iterations
breaks=c(0.25,0.50,0.75)
ed=1:dd
adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="N")
# Compute the median of the iterations
breaks=c(0.50)
# Compute a raster with the  median of the iterations
breaks=c(0.50)
hs.r <- adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="N")
hs.r
hs.r$`Host-seeking_q_0.5`
plot(hs.r$`Host-seeking_q_0.5`$day30)
hs.r <- adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
hs.r
names(hs.r)
View(hs.r)
dim(hs.r)
debugonce(adci)
adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
adci(simout, eval_date=30, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
pippo <-adci(simout, eval_date=30, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
pippo
pippo <-adci(simout, eval_date=1, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
pippo
pippo <-adci(simout, eval_date=10, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="O")
pippo
pippo <-adci(simout, eval_date=10, breaks=breaks,
stage="Adults",
type="O")
pippo
ed <- 1:dd
hs.r <- adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="N")
hs.r <- adci(simout, eval_date=ed, breaks=breaks,
stage="Adults",
sub_stage = "Host-seeking", type="N")
hs.r$`Host-seeking_q_0.5`
plot(hs.r$`Host-seeking_q_0.5`$day30)
plot(hs.r$`Host-seeking_q_0.5`$day29)
plot(hs.r$`Host-seeking_q_0.5`$day5)
plot(hs.r$`Host-seeking_q_0.5`$day7)
plot(hs.r$`Host-seeking_q_0.5`$day10)
plot(hs.r$`Host-seeking_q_0.5`$day8)
r1 <- raster(matrix(1:12, nrow = 3))
r1
library(raster)
r1 <- raster(matrix(1:12, nrow = 3))
r1
x <- crop(r1, extent(0,ncol(r1),0,nrow(r1)))
x
plotRGB(x)
?plotRGB
raster::plotRGB(x)
library(raster)
r1 <- raster(matrix(1:12, nrow = 3))
r1
x <- crop(r1, extent(0,ncol(r1),0,nrow(r1)))
raster::plotRGB(x)
plot(x)
x1 <- 0:ncol(x)
y1 <- 0:nrow(x)
z <- matrix(1, nrow=length(x1), ncol=length(y1))
col.mat <- t(apply(matrix(rgb(getValues(x)/255), nrow=nrow(x), byrow=TRUE), 2, rev))
# Rotate 45 degrees
persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90,
col = col.mat, scale=FALSE, border=NA, box=FALSE)
col.mat <- t(apply(matrix(rgb(values(x)/255), nrow=nrow(x), byrow=TRUE), 2, rev))
col.mat <- t(apply(matrix((values(x)/255), nrow=nrow(x), byrow=TRUE), 2, rev))
col.mat
# Rotate 45 degrees
persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90,
col = col.mat, scale=FALSE, border=NA, box=FALSE)
persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90,
col = col.mat, scale=FALSE, border=NA, box=FALSE)
persp(x1, y1, z, zlim=c(0,2), theta = 20, phi = 90,
col = col.mat, scale=FALSE, border=NA, box=FALSE)
y1
rotation <- function(df, degree) {
dfr <- df
degree <- pi * degree / 180
l <- sqrt(df$start1^2 + df$start2^2)
teta <- atan(df$start2 / df$start1)
dfr$start1 <- round(l * cos(teta - degree))
dfr$start2 <- round(l * sin(teta - degree))
return(dfr)
}
test <- data.frame(start1=c(1,1,1,1,2,2,2,3,3,4),
start2=c(1,2,3,4,2,3,4,3,4,4),
logFC=c(5,5,1,0,8,0,5,2,4,3))
ggplot(test, aes(start1, start2)) +
geom_tile(aes(fill = logFC), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
library(ggplot2)
test <- data.frame(start1=c(1,1,1,1,2,2,2,3,3,4),
start2=c(1,2,3,4,2,3,4,3,4,4),
logFC=c(5,5,1,0,8,0,5,2,4,3))
ggplot(test, aes(start1, start2)) +
geom_tile(aes(fill = logFC), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
rotation <- function(df, degree) {
dfr <- df
degree <- pi * degree / 180
l <- sqrt(df$start1^2 + df$start2^2)
teta <- atan(df$start2 / df$start1)
dfr$start1 <- round(l * cos(teta - degree))
dfr$start2 <- round(l * sin(teta - degree))
return(dfr)
}
test2 <- rotation(test, -90)
ggplot(test2, aes(start1, start2)) +
geom_tile(aes(fill = logFC), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
test2
r1
as.data.frame(r1, xy=TRUE)
r1.df<-as.data.frame(r1, xy=TRUE)
rotation <- function(df, degree) {
dfr <- df
degree <- pi * degree / 180
l <- sqrt(df$[,1]^2 + df$[,2]^2)
rotation <- function(df, degree) {
dfr <- df
degree <- pi * degree / 180
l <- sqrt(df[,1]^2 + df[,2]^2)
teta <- atan(df[,2] / df[,1])
dfr[,1] <- round(l * cos(teta - degree))
dfr[,2] <- round(l * sin(teta - degree))
return(dfr)
}
test2 <- rotation(test, -90)
ggplot(test2, aes(start1, start2)) +
geom_tile(aes(fill = logFC), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
r1.df<-as.data.frame(r1, xy=TRUE)
ggplot(r1.df, aes(x, y)) +
geom_tile(aes(fill = layer), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
ggplot(rotation(r1.df, -90), aes(x, y)) +
geom_tile(aes(fill = layer), colour = "gray", size=0.05) +
scale_fill_gradientn(colours=c("#0000FF","white","#FF0000"), na.value="#DAD7D3")
rotation(r1.df, -90)
rotation(r1.df, -90)
r1.df
#---- dynamAedes ----
setwd("/home/daniele/GitHub/dynamAedes/")
# token "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"
library(devtools)
library(roxygen2)
library(usethat)
# devtools::create("yourPkg")
# devtools::install_github("mattmar/dynamAedes")
devtools::load_all(".") # Working directory should be in the package directory
pippo <- multipleIntro(startd = "2022-06-10",
endd = "2022-08-10",
n.intro = 4,
intro.eggs = 100,
sd_eggs = 15,
scenario = "ff",
iter = 2)
pippo
# model's arguments
startd = "2022-06-10"
endd = "2022-08-10"
intro.eggs = pippo
temps.matrix = matrix(data =NA, nrow=1, ncol = as.integer(as.Date(endd) - as.Date(startd)))
# model's internal objects
dayspan <- as.integer(as.Date(endd) - as.Date(startd))
iteration <- 1
de <- 1
p.life.a <- array(0,c(4,nrow(temps.matrix),6*de), dimnames = list(c("egg", "juvenile", "adult", "diapause_egg"), NULL, paste0("sc",1:(6*de)))); storage.mode(p.life.a) <- "integer"
p.life.a
is.list(intro.eggs)
e.intro.n <- as.vector(intro.eggs[[iteration]][1])
e.intro.n
m.intro.eggs <- intro.eggs[[iteration]][-1]
m.intro.eggs
count.mIntro <- which(seq.Date(from=as.Date(startd), to= as.Date(endd), by ="day") %in% as.Date(names(m.intro.eggs)))
count.mIntro
#add it before the day loop
if(is.list(intro.eggs)){
e.intro.n <- as.vector(intro.eggs[[iteration]][1])
m.intro.eggs <- intro.eggs[[iteration]][-1]
count.mIntro <- which(seq.Date(from=as.Date(startd), to= as.Date(endd), by ="day") %in% as.Date(names(m.intro.eggs)))
}
count.mIntro
dayspan
#---- Giovanni's smart solution ----
startd = "2022-06-10"
endd = "2022-08-10"
seq.Date(from = as.Date(startd), to= as.Date(endd), by="day")
intro.eggs
if(any(count.mIntro == length(counter))){eggs2add <- pippo[[iteration]][-1]}
intro.eggs
intro.eggs <- vector(0, length = length(myDates))
myDates <- seq.Date(from = as.Date(startd), to= as.Date(endd), by="day")
intro.eggs <- vector(0, length = length(myDates))
length(myDates)
myDates <- seq.Date(from = as.Date(startd), to= as.Date(endd), by="day")
myDates
intro.eggs <- vector(0, length = length(myDates))
intro.eggs <- vector(length = length(myDates))
intro.eggs
intro.eggs <- rep(0, length = length(myDates))
intro.eggs
# model's arguments
startd = "2022-06-10"
endd = "2022-08-10"
intro.eggs = pippo
temps.matrix = matrix(data =NA, nrow=1, ncol = as.integer(as.Date(endd) - as.Date(startd)))
# model's internal objects
dayspan <- as.integer(as.Date(endd) - as.Date(startd))
dayspan
# model's internal objects
dayspan <- as.integer(as.Date(endd) - as.Date(startd)) # check anche nel codice sta cosa
iteration <- 1
de <- 1
intro.eggs[[iteration]]
count.mIntro <- which(seq.Date(from=as.Date(startd), to= as.Date(endd), by ="day") %in% as.Date(names(intro.eggs[[iteration]])))
count.mIntro
e.intro.n
myDates <- seq.Date(from = as.Date(startd), to= as.Date(endd), by="day")
e.intro.n <- rep(0, length = length(myDates))
e.intro.n
intro.eggs[[iteration]]
e.intro.n[count.mIntro]<- as.numeric(intro.eggs[[iteration]])
e.intro.n
e.intro.n
#---- Giovanni's smart solution ----
if(is.list(intro.eggs)){
myDates <- seq.Date(from = as.Date(startd), to= as.Date(endd), by="day")
e.intro.n <- rep(0, length = length(myDates))
count.mIntro <- which(seq.Date(from=as.Date(startd), to= as.Date(endd), by ="day") %in% as.Date(names(intro.eggs[[iteration]])))
e.intro.n[count.mIntro]<- as.numeric(intro.eggs[[iteration]])
}
#reproducing model output structure
myOutList<-vector("list", dayspan)
counter <- NULL
for (day in 1:dayspan){ # dayspan;Matteo starts from 2, I don't understand why
# day= 21
print(day)
counter <- append(counter,day)
p.life.a[1,,(4*de)] <- if(length(counter)==1) {
e.intro.n[day]
} else {
p.life.a[1,,(4*de)] + e.intro.n[day]
}
myOutList[[day]] <- p.life.a[1,,(4*de)]
} #end of day loop
myOutList
pippo
# model's internal objects
dayspan <- as.integer(as.Date(endd) - as.Date(startd)) +1# check anche nel codice sta cosa
#reproducing model output structure
myOutList<-vector("list", dayspan)
counter <- NULL
for (day in 1:dayspan){ # dayspan;Matteo starts from 2, I don't understand why
# day= 21
print(day)
counter <- append(counter,day)
p.life.a[1,,(4*de)] <- if(length(counter)==1) {
e.intro.n[day]
} else {
p.life.a[1,,(4*de)] + e.intro.n[day]
}
myOutList[[day]] <- p.life.a[1,,(4*de)]
} #end of day loop
myOutList
