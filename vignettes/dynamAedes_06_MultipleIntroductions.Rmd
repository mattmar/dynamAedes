---
title: "06. Multiple introductions of Aedes propagules"
author: "Emmanuelle Kern, Ilaria Dorigatti, Daniele Da Re, Matteo Marcantonio"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
vignette: |
  %\VignetteIndexEntry{06. Multiple introductions of Aedes propagules}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  %\number_sections: yes
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.width=10, fig.height=10, fig.asp = 0.618, out.width = "95%", fig.align = "center", fig.dpi = 150, collapse = FALSE, comment = "#")
options(rmarkdown.html_vignette.check_title = FALSE)
```

This tutorial explains step-by-step the main features of **dynamAedes** package, a unified modelling framework for invasive *Aedes* mosquitoes. Users can apply the stochastic, time-discrete and spatially-explicit population dynamical model initially developed in [Da Re et al., (2021)](https://doi.org/10.1016/j.ecoinf.2020.101180) for *Aedes aegypti* and then expanded for other three species: *Ae. albopictus*, *Ae. japonicus* and *Ae. koreicus* [Da Re et al., (2022)](https://doi.org/10.1186/s13071-022-05414-4).

The model is driven by temperature, photoperiod and intra-specific larval competition and can be applied to three different spatial scales: punctual, local and regional. These spatial scales consider different degrees of spatial complexity and data availability, by accounting for both active and passive dispersal of the modelled mosquito species as well as for the heterogeneity of input temperature data.

We will describe the multiple introduction of mosquito propagules for *Ae. albopictus* at the punctual and regional scales by using a simulated temperature dataset. 

# 1. Multiple introductions

**Add a description of what the function does here.**

# 2. Punctual scale model 

## 2.1 Input data and model settings

At the punctual scale, the model only requires a temperature time series, recorded by e.g. a weather station, provided as a numerical matrix (in degree Celsius). For the purpose of this tutorial, we simulate a 1-year long temperature time series and, for the sake of brevity, we will not discuss the chunks of code already presented in other tutorials. 

```{r,  message=FALSE, warning=FALSE, echo=FALSE}
#Load packages
# simulate temperatures
library(eesim)
# plotting
library(ggplot2)
Sys.setlocale("LC_TIME", "en_GB.UTF-8")  
```

```{r, warning=FALSE}
ndays <- 365*1 #length of the time series in days
set.seed(123)
sim_temp <- create_sims(n_reps = 1, 
  n = ndays, 
  central = 16, 
  sd = 2, 
  exposure_type = "continuous", 
  exposure_trend = "cos1", exposure_amp = -1.0, 
  average_outcome = 12,
  outcome_trend = "cos1",
  outcome_amp = 0.8, 
  rr = 1.0055)
```

Define model parameters

```{r, warning=FALSE}
# Model settings
## Define the day of introduction (July 1st is day 1)
str <- "2000-07-01"
## Define the end-day of life cycle (August 1st is the last day)
endr <- "2000-08-01"
## Define the number of model iterations
it <- 1 # The higher the number of simulations the better
## Define the number of liters for the larval density-dependent mortality
habitat_liters <- 1
## Define latitude and longitude for the diapause process
myLat <- 42
myLon <- 7
## Define the number of parallel processes (for sequential iterations set nc=1)
cl <- 1
## convert float temperatures to integer
df_temp <- data.frame("Date" = sim_temp[[1]]$date, "temp" = sim_temp[[1]]$x)
w <- t(as.integer(df_temp$temp*1000)[format(as.Date(str)+1,"%j"):format(as.Date(endr)+1,"%j")])
```


Multiple introductions: define the number of eggs to be introduced, when, and how many times
```{r, warning=FALSE}
ie <- multipleIntro(startd = str,
              endd =  "2000-07-28",
              n.intro = 4,
              intro.eggs = 1000,
              sd_eggs = 15,
              scenario = "ff",
              iter = it)
ie
```

## 2.2 Run the model

```{r,  message=FALSE, warning=FALSE, results='hide'}
simout <- dynamAedes.m(species="albopictus", 
 scale="ws",  
 jhwv=habitat_liters,  
 temps.matrix=w,  
 startd=str, 
 endd=endr,  
 n.clusters=cl, 
 iter=it,  
 intro.eggs=ie,  
 compressed.output=TRUE, 
 lat=myLat, 
 long=myLon,
 verbose=FALSE,
 seeding=TRUE)
```

## 2.3 Analyse the results
A first summary of simulations can be obtained with:
```{r}
summary(simout)
```

The *simout* object is a S4 object where the outputs of the model and related details are saved in different slot. For example, the number of model iterations is saved in: 
```{r, warning=FALSE, message=FALSE}
simout@n_iterations
```
**should implement S4 object here for the multiple introductions**

## 2.4 Derive abundance 95% CI for a specific sub-compartment 
We can use the auxiliary functions of the package to analyse the results. We now compute the interquantile range abundance for the host-seeking sub-compartment of the simulated population using the function *adci*.
```{r, message=FALSE, warning=FALSE}
# Retrieve the maximum number of simulated days
dd <- max(simout)

# Compute the inter-quartile of abundances along the iterations
breaks <- c(0.25,0.50,0.75)
ed <- 1:dd

outdf <- rbind(
  adci(simout, eval_date=ed, breaks=breaks, stage="Eggs"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Juvenile"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Adults"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Dia"))
outdf$stage <- factor(outdf$stage, levels= c('Egg', 'DiapauseEgg', 'Juvenile', 'Adult'))
outdf$Date <- rep(seq.Date(as.Date(str), as.Date(endr), by="day"), 4)
```

Then we can look at the time series of the population dynamics stage by stage.
```{r, message=FALSE, warning=FALSE}
intro.dates <- data.frame(Date = as.Date(c(sapply(ie, names))), 
                                         stage = "Egg", 
                                          n.intro = unlist(ie))
intro.dates$X50. <- subset(outdf, stage=="Egg")[which(subset(outdf, stage=="Egg")$"Date" %in% intro.dates$Date), "X50."]

ggplot(outdf, aes(x=Date, y=X50., group=factor(stage), col=factor(stage))) +
  ggtitle("Ae. albopictus Interquantile range abundance") +
  geom_ribbon(aes(ymin=X25., ymax=X75., fill=factor(stage)), 
    col="white", 
    alpha=0.2, 
    outline.type="full") +
  geom_line(linewidth=0.8) +
  geom_segment(data=intro.dates, aes(x=Date, xend=Date,  y = rep(0,4), yend=X50., group=factor(stage)), col="black")+
  geom_point(data=intro.dates, aes(x=Date, yend=X50.), col="black")+
  geom_text(data=intro.dates, aes(x=Date, yend=X50., label = paste("+", n.intro )), vjust =-1)+
  labs(x="Date", y="Interquantile range abundance", col="Stage", fill="Stage") +
  facet_wrap(~stage, scales = "free_y") +
  theme_light() +
  theme(legend.position="bottom",  
    text = element_text(size=16), 
    strip.text = element_text(face = "italic"))

```
# 3. Regional scale model 

We can now repeat the exercise for a regional scale model.

```{r, results='hide'}
library(gstat)
library(terra)
gridDim <- 20 # 5000m/250 m = 20 columns and rows
xy <- expand.grid(x=1:gridDim, y=1:gridDim)
varioMod <- vgm(psill=0.5, range=100, model='Exp') # psill = partial sill = (sill-nugget)
# Set up an additional variable from simple kriging
zDummy <- gstat(formula=z~1, 
                locations = ~x+y, 
                dummy=TRUE,
                beta=1, 
                model=varioMod, 
                nmax=1)
# Generate a randomly autocorrelated predictor data field
set.seed(123)
xyz <- predict(zDummy, newdata=xy, nsim=1)
utm32N <- "+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs"
r <- terra::rast(nrow=gridDim, ncol=gridDim, crs=utm32N, ext=terra::ext(1220000,1225000, 5700000,5705000))
terra::values(r) <- xyz$sim1
# plot(r, main="SAC landscape")

# convert to a data.frame
df <- data.frame("id"=1:nrow(xyz), terra::crds(r))
bbox <- terra::as.polygons(terra::ext(r), crs=utm32N)

# Store Parameters for autocorrelation
autocorr_factor <- terra::values(r)

# "expand onto space" the temperature time series by multiplying it with the autocorrelated surface simulated above. 
mat <- do.call(rbind, lapply(1:ncell(r), function(x) {
	d_t <- sim_temp[[1]]$x*autocorr_factor[[x]]
	return(d_t)
}))

# format simulated temperature
names(mat) <- paste0("d_", 1:ndays)
df_temp <- cbind(df, mat)
w <- sapply(df_temp[,-c(1:3)], function(x) as.integer(x*1000))
# define a two-column matrix of coordinates to identify each cell in the lattice grid.
cc <- df_temp[,c("x","y")]
```


```{r,  message=FALSE, warning=FALSE, results='hide'}
simout <- dynamAedes.m(species="albopictus", 
            scale="rg",  
            jhwv=habitat_liters,  
            temps.matrix=w[,as.numeric(format(as.Date(str),"%j")):as.numeric(format(as.Date(endr),"%j"))],
            coords.proj4=utm32N,
            cells.coords=as.matrix(cc),
            startd=str,
            endd=endr,
            n.clusters=cl,
            iter=it,
            intro.eggs=ie,
            compressed.output=TRUE,
            seeding=TRUE,
            verbose=FALSE)
```

```{r, warning=FALSE}
summary(simout)
```
## 3.1 Derive abundance 95% CI for each life stage and in each day

We can now compute the interquantile range abundance of the simulated population using the function *adci* over the whole landscape. 
```{r message=FALSE, warning=FALSE, evaluate=FALSE}
dd <- max(simout) #retrieve the maximum number of simulated days

# Compute the inter-quartile of abundances along the iterations
breaks <- c(0.25,0.50,0.75)
ed <- 1:dd

# type "O" derives a non-spatial time series
outdf <- rbind(
  adci(simout, eval_date=ed, breaks=breaks, stage="Eggs", type="O"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Juvenile", type="O"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Adults", type="O"),
  adci(simout, eval_date=ed, breaks=breaks, stage="Dia", type="O")
  )
outdf$stage <- factor(outdf$stage, levels= c('Egg', 'DiapauseEgg', 'Juvenile', 'Adult'))
outdf$Date <- rep(seq.Date(as.Date(str), as.Date(endr), by="day"), 4)
```

Then we can look at the time series of the population dynamics stage by stage at the whole landscape level.
```{r, message=FALSE, warning=FALSE}
intro.dates <- data.frame(Date = as.Date(c(sapply(ie, names))), 
                                         stage = "Egg", 
                                          n.intro = unlist(ie))
intro.dates$X50. <- subset(outdf, stage=="Egg")[which(subset(outdf, stage=="Egg")$"Date" %in% intro.dates$Date), "X50."]

ggplot(outdf, aes(x=Date, y=X50., group=factor(stage), col=factor(stage))) +
  ggtitle("Ae. albopictus Interquantile range abundance") +
  geom_ribbon(aes(ymin=X25., ymax=X75., fill=factor(stage)), 
    col="white", 
    alpha=0.2, 
    outline.type="full") +
  geom_line(linewidth=0.8) +
  geom_segment(data=intro.dates, aes(x=Date, xend=Date,  y = rep(0,4), yend=X50., group=factor(stage)), col="black")+
  geom_point(data=intro.dates, aes(x=Date, yend=X50.), col="black")+
  geom_text(data=intro.dates, aes(x=Date, yend=X50., label = paste("+", n.intro )), vjust =-1)+
  labs(x="Date", y="Interquantile range abundance", col="Stage", fill="Stage") +
  facet_wrap(~stage, scales = "free_y") +
  theme_light() +
  theme(legend.position="bottom",  
    text = element_text(size=16), 
    strip.text = element_text(face = "italic"))
```

## 3.2 Abundance raster

Compute the egg abundance raster before and after the second introduction event.
```{r,  message=FALSE, warning=FALSE, echo=FALSE}
# Retrieve the maximum number of simulated days
dd <- max(simout)

#retrieve in which day of the simulation the multiple introductions happened
intro.dates <- data.frame(Date = seq.Date(from = as.Date(str), to= as.Date(endr), length.out = dd))
intro.dates$IntroDay<-1:nrow(intro.dates)
intro.dates <- intro.dates[which(intro.dates$Date %in% as.Date(c(sapply(ie, names)))),]
intro.dates
```

In our case, we will produce two rasters, one on the day before the second introduction (day 9), and one on the day of the second introduction (day 10).

```{r,  message=FALSE, warning=FALSE, echo=FALSE}
# Compute a raster with the  median of the iterations
breaks <- c(0.50)
eggs.r <- adci(simout, eval_date=9:10, breaks=breaks, 
     stage="Eggs",
      type="N")
# inspect the raster
eggs.r$q_0.5
# plot the raster with the median egg abundace
plot(eggs.r$q_0.5,  
     legend ="bottom",
     range = c(0, 3000))
```



